# Java开发设计模式

- 创建型模式：
  - 单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式。
- 结构型模式：
  - 适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式
- 行为型模式：
  - 模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式

## OOP七大原则

- 开闭原则：对扩展开放，对修改关闭
- 里氏替换原则：继承必须确保超类所拥有的性质在子类中仍然成立
- 依赖倒置原则：要面向接口编程，不要面向实现编程
- 单一职责原则：控制类的粒度大小、将对象解耦、提高内聚性
- 接口隔离原则：要为各个类建立他们需要的专用接口
- 迪米特法则：只与你的直接朋友交谈，不跟“陌生人”说话
- 合成复用原则：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现

## 单例模式

### 单例模式的定义与特点

单例（Singleton）模式的定义：指一个类只有一个实例，且该类能自行创建这个实例的一种模式

单例模式有 3 个特点：

1. 单例类只有一个实例对象；
2. 该单例对象必须由单例类自行创建；
3. 单例类对外提供一个访问该单例的全局访问点。

### 单例模式的优点和缺点

1. 单例模式的优点

- 单例模式可以保证内存里只有一个实例，减少了内存的开销。
- 可以避免对资源的多重占用。
- 单例模式设置全局访问点，可以优化和共享资源的访问。

2. 单例模式的缺点

- 单例模式一般没有接口，扩展困难。如果要扩展，则除了修改原来的代码，没有第二种途径，违背开闭原则。
- 在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象。
- 单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。

### 单例模式的应用场景

对于`Java`来说，单例模式可以保证在一个 JVM 中只存在单一实例。单例模式的应用场景主要有以下几个方面。

- 需要频繁创建的一些类，使用单例可以降低系统的内存压力，减少 GC。
- 某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。
- 某些类创建实例时占用资源较多，或实例化耗时较长，且经常使用。
- 某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。
- 频繁访问数据库或文件的对象。
- 对于一些控制硬件级别的操作，或者从系统上来讲应当是单一控制逻辑的操作，如果有多个实例，则系统会完全乱套。
- 当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。

### 单例模式的结构与实现

1. 单例模式的结构

单例模式的主要角色如下。

- 单例类：包含一个实例且能自行创建这个实例的类。
- 访问类：使用单例的类。

2. 单例模式的实现

- 懒汉式单例

该模式的特点是类加载时没有生成单例，只有当第一次调用 getlnstance 方法时才去创建这个单例。代码如下：

```java
public class LazySingleton {
  	//保证 instance 在所有线程中同步
    private static volatile LazySingleton instance = null;    
  
		//private 避免类在外部被实例化
    private LazySingleton() {
    }    

	  //getInstance 方法前加同步
	  // 双重检测锁模式的 懒汉式单例，DCL懒汉式
    public static synchronized LazySingleton getInstance() {
        if (instance == null) {
            instance = new LazySingleton();	// 不是一个原子性操作
          /**
          *	1. 非配内存空间
          *	2. 执行构造方法，初始化对象
          * 3， 把这个对象指向这个空间
          */
        }
        return instance;
    }
}
```

注意：如果编写的是多线程程序，则不要删除上例代码中的关键字 volatile 和 synchronized，否则将存在线程非安全的问题。如果不删除这两个关键字就能保证线程安全，但是每次访问时都要同步，会影响性能，且消耗更多的资源，这是懒汉式单例的缺点。

- 饿汉式单例

该模式的特点是类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了。

```java
public class HungrySingleton {
    private static final HungrySingleton instance = new HungrySingleton();

    private HungrySingleton() {
    }

    public static HungrySingleton getInstance() {
        return instance;
    }
}
```

饿汉式单例在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以是线程安全的，可以直接用于多线程而不会出现问题。

## 工厂模式

在日常开发中，凡是需要生成复杂对象的地方，都可以尝试考虑使用工厂模式来代替。

> 复杂对象指的是类的构造函数参数过多等对类的构造有影响的情况，因为类的构造过于复杂，如果直接在其他业务类内使用，则两者的耦合过重，后续业务更改，就需要在任何引用该类的源代码内进行更改，光是查找所有依赖就很消耗时间了，更别说要一个一个修改了。

### 工厂模式作用

- 实现了创建者和调用者的分离
- 详细分类：
  - 简单工厂模式
  - 工厂方法模式
  - 抽象工厂模式

### OOP七大原则

- 开闭原则：对扩展开放，对修改关闭
- 依赖倒置原则：要面向接口编程，不要面向实现编程
- 迪米特法则：只与你的直接朋友交谈，不跟“陌生人”说话

### 核心本质

- 实例化对象不使用new，用工厂方法代替
- 将选择实体类，创建对象统一管理和控制。从而将调用者跟我们的实现类解耦

### 三种模式

- 简单工厂模式
  - 用来生产同一等级结构中的任意产品（对于增加新的产品，需要覆盖已有代码）
- 工厂方法模式
  - 用来生产同一等级结构中的固定产品（支持增加任意产品）
- 抽象工厂模式
  - 围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。

## 抽象工厂模式

### 抽象工厂模式定义

抽象工厂模式提供了一个创建一系列相关或者相互依赖对象的接口，无需指定它们具体的类

### 适用场景

- 客户端（应用层）不依赖于产品类实例如何被创建、实现等细节
- 强调一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量的重复代码
- 提供一个产品类的库，所有的产品以同样的接口出现，从而使得客户端不依赖于具体的实现

### 优点

- 具体产品在应用层的代码隔离，无需关心创建的细节
- 将一个系列的产品统一到一起创建

### 缺点

- 规定了所有可能被创建的产品的集合，产品族中扩展新的产品困难
- 增加了系统的抽象性和理解难度